default:
  tags:
    # Use an account that maps will switch users depending on the repo it
    # runs on
    - bb5_map

variables:
  # Default values for Slurm
  SALLOC_ACCOUNT: proj12
  SBATCH_ACCOUNT: proj12
  SLURM_ACCOUNT: proj12
  SALLOC_PARTITION: prod
  SBATCH_PARTITION: prod
  SLURM_PARTITION: prod
  # We never use the runner's native git checkout ability. We use `git clone`
  # explicitly to get Spack, and then Spack itself clones any projects we want
  # to build.
  GIT_STRATEGY: none
  # Make ${CI_BUILDS_DIR} points to a top-level pipeline-global directory.
  bb5_build_dir: pipeline
  # Make the top-level jobs launched by the GitLab CI use the same account
  bb5_account: proj12
  # Shared input directory for HPC integration tests.
  DATADIR: /gpfs/bbp.cscs.ch/project/proj12/jenkins

# Set up a clone of Spack for use in this pipeline and export a variable called
# SPACK_ROOT that points to it.
.spack_setup:
  stage: .pre
  variables:
    # Put the clone of spack at {pipeline_id}/{spack_setup_jobid}/spack, there
    # is no need to include the path to the project running the pipeline (e.g.
    # hpc/coreneuron). It makes sense to include the job ID because it means
    # that the spack_setup job can be retried in case of a transient failure.
    GIT_CLONE_PATH: ${CI_BUILDS_DIR}/${CI_JOB_ID}
    # What version of BlueBrain/spack to use. You can override this if need be.
    SPACK_BRANCH: develop
    # This is a trivial setup job, it doesn't need many resources
    bb5_memory: 512M
    bb5_constraint: knl
    bb5_cpus_per_task: 1
    bb5_duration: "10:00"
  script:
    - echo Using ${PWD} as a working directory common to the whole pipeline...
    - echo Checking out the ${SPACK_BRANCH} of Spack...
    - git clone --depth 1 --single-branch --branch ${SPACK_BRANCH} https://github.com/BlueBrain/spack.git spack
    - cp /gpfs/bbp.cscs.ch/ssd/apps/hpc/jenkins/config/*.yaml spack/etc/spack
    - SPACK_ROOT=${PWD}/spack
    - echo "SPACK_ROOT=${SPACK_ROOT}" > spack_dirs.env
    - . ${SPACK_ROOT}/share/spack/setup-env.sh
  artifacts:
    when: always
    reports:
      dotenv: spack_dirs.env

# Augmented version of .spack_setup that additionally enables ccache in the
# Spack configuration and exports a variable SPACK_USE_CCACHE=true for use in
# later stages.
.spack_setup_ccache:
  extends: .spack_setup
  script:
    - !reference [.spack_setup, script]
    # Enable ccache
    - spack config --scope site add "config:ccache:true"
    # Dump the configuration for debugging/reference purposes.
    - spack config get config
    # In principle later stages could use some kind of
    # `spack config get config | grep ccache` construction, but this is simpler
    - echo "SPACK_USE_CCACHE=true" >> spack_dirs.env

.spack_build:
  stage: build
  variables:
    # Work in a directory unique to this job.
    GIT_CLONE_PATH: ${CI_BUILDS_DIR}/${CI_JOB_ID}
    # By default we update the `develop` version of the Spack recipe to point
    # to this commit ("the commit the pipeline is being run on"). This variable
    # can be overriden, also with tag="..." or branch="...".
    SPACK_PACKAGE_REF: commit="${CI_COMMIT_SHA}"
  before_script:
    # Change the staging directory to something specific to this GitLab CI job.
    # This stops Spack from cleaning up previous build directories, which
    # causes errors if you try to run "test:library" in parallel with
    # "build:application_that_depends_on_library".
    - SPACK_BUILD="${PWD}/spack-build"
    # Dump the environment for debugging purposes
    - env -0 | sort -z | xargs -0 -L 1 echo > initial_environment.env
    # SPACK_ROOT is passed in by the dotenv artifacts of a previous job.
    - . ${SPACK_ROOT}/share/spack/setup-env.sh
    # Tell Spack which working directory to use in this job. It would be nice
    # if this first part could be done with `spack config add`...
    - SPACK_CONFIG=${PWD}/spack-config
    - mkdir ${SPACK_CONFIG}
    - echo -e "config:\n  build_stage:\n  - ${SPACK_BUILD}" > ${SPACK_CONFIG}/config.yaml
    - spack --config-scope ${SPACK_CONFIG} config blame config
    - if [ "${SPACK_EXPORT_SPECS}" ]; then
    - spack export --scope=command_line --module tcl ${SPACK_EXPORT_SPECS} > ${SPACK_CONFIG}/packages.yaml
    - cat ${SPACK_CONFIG}/packages.yaml
    - fi
    # Tell Git how to re-write BBP GitLab URLs to use a token instead of SSH
    - export XDG_CONFIG_HOME=${PWD}/local_config
    - mkdir -p "${XDG_CONFIG_HOME}/git"
    - echo -e "[url \"https://gitlab-ci-token:${CI_JOB_TOKEN}@bbpgitlab.epfl.ch/\"]\n  insteadOf = git@bbpgitlab.epfl.ch:" > "${XDG_CONFIG_HOME}/git/config"
    - cat "${XDG_CONFIG_HOME}/git/config"
    # Modify the Spack recipe so the develop version points at ${SPACK_PACKAGE_REF}
    - SPACK_PACKAGE_FILE="$(spack location -p ${SPACK_PACKAGE})/package.py"
    # Remove any commit/tag/branch identifier from the line containing the
    # develop version and substitute in our desired commit hash. Don't
    # change anything if ${SPACK_PACKAGE_REF} is unset or an empty string.
    - if [ "${SPACK_PACKAGE_REF}" ]; then
    # Note that [^\2] doesn't work, backreferences are not expanded there, so
    # we have to use [^\"'].
    - sed -i -e "/^\s*version\s*(\s*\(['\"]\)develop\1/ { s/,\s*\(commit\|tag\|branch\)=\([\"']\)[^\"']\+\2//g; s#)#, ${SPACK_PACKAGE_REF})#; }" "${SPACK_PACKAGE_FILE}"
    - (cd $(dirname "${SPACK_PACKAGE_FILE}") && git diff "${SPACK_PACKAGE_FILE}")
    - fi
    # Get the hash of the version we're about to install. First, construct the
    # full spec. This includes ${SPACK_PACKAGE_COMPILER} and ${SPACK_PACKAGE_DEPENDENCIES} if
    # they are not empty.
    - SPACK_FULL_SPEC=${SPACK_PACKAGE}@develop${SPACK_PACKAGE_COMPILER:+%}${SPACK_PACKAGE_COMPILER}${SPACK_PACKAGE_SPEC}${SPACK_PACKAGE_DEPENDENCIES:+^}${SPACK_PACKAGE_DEPENDENCIES}
    - echo "Preparing to install ${SPACK_FULL_SPEC}"
    # Then extract the hash
    - JSON_SPEC=$(spack --config-scope ${SPACK_CONFIG} spec --json ${SPACK_FULL_SPEC})
    - SPACK_INSTALLED_HASH=$(echo "${JSON_SPEC}" | python -c "import json, sys; print(json.loads(sys.stdin.read())[\"spec\"][0][\"${SPACK_PACKAGE}\"][\"hash\"])")
    - echo "Determined its hash will be ${SPACK_INSTALLED_HASH}"
    # Construct the directories Spack is going to use to build the package.
    # For a CMake project the source directory will be:
    #   ${SPACK_STAGE_DIR}/spack-src
    # and the build directoy will by default be
    #   ${SPACK_STAGE_DIR}/spack-build-{short_hash}
    # TODO: to improve ccache support, drop the {short_hash} part. This needs a
    # change to `cmake.py` in Spack.
    - SPACK_STAGE_DIR=${SPACK_BUILD}/spack-stage-${SPACK_PACKAGE}-develop-${SPACK_INSTALLED_HASH}
    - SPACK_BUILD_DIR=${SPACK_STAGE_DIR}/spack-build-${SPACK_INSTALLED_HASH:0:7}
    - SPACK_SOURCE_DIR=${SPACK_STAGE_DIR}/spack-src
    # ccache-specific setup, only if it was enabled
    - if [ ${SPACK_USE_CCACHE+x} ]; then
    # Load a more modern ccache version.
    - module load unstable ccache
    # Tell ccache to use paths relative to this directory, to avoid polluting
    # the cache with pipeline- and job-specific paths.
    - export CCACHE_BASEDIR=${SPACK_STAGE_DIR}
    - export CCACHE_DIR=${CI_PROJECT_DIR}/ccache
    # For debugging cache misses.
    # - export CCACHE_DEBUG=true
    # - export CCACHE_DEBUGDIR=${CI_PROJECT_DIR}/ccache_debug/
    # We can't assume there was a valid GitLab cache, so create empty
    # directories if needed.
    - mkdir -p ${CCACHE_BASEDIR} # ${CCACHE_DEBUGDIR}
    # Zero the statistics.
    - ccache -z
    - ccache -s
    - fi
    # end ccache-specific setup
  script:
    # Spack needs a recent Git version.
    - module load unstable git
    # *Un*install this spec first. This can be helpful when resubmitting failed
    # jobs, for example if the GitLab job finalisation fails then the package
    # might have been successfully installed to the pipeline's Spack tree.
    - spack --config-scope ${SPACK_CONFIG} uninstall -y /${SPACK_INSTALLED_HASH} || true
    # Install that new version. Use an absolute path for install.xml so it ends
    # up in the original job working directory even if that's no longer the
    # working directory.
    - spack --config-scope ${SPACK_CONFIG} install -j${SLURM_JOB_CPUS_PER_NODE} --log-format=junit --log-file=${CI_PROJECT_DIR}/install.xml --keep-stage ${SPACK_FULL_SPEC}
    # Report ccache statistics if ccache was enabled.
    - if [ ${SPACK_USE_CCACHE+x} ]; then ccache -s; fi
    # Copy some files to the original working directory that artifacts are
    # saved from.
    - cp ${SPACK_STAGE_DIR}/spack-{build-env,build-out,configure-args}.txt ${CI_PROJECT_DIR}/
    # Append to a list /hash1/hash2/hash3/... of packages that have been
    # installed in this chain of .spack_build jobs.
    - SPACK_PACKAGE_DEPENDENCIES=${SPACK_PACKAGE_DEPENDENCIES}/${SPACK_INSTALLED_HASH}
    - echo "SPACK_ROOT=${SPACK_ROOT}" > ${CI_PROJECT_DIR}/spack_build_dir.env # so other jobs don't need to depend explicitly on spack_setup
    - if [ ${SPACK_USE_CCACHE+x} ]; then echo "SPACK_USE_CCACHE=${SPACK_USE_CCACHE}" >> ${CI_PROJECT_DIR}/spack_build_dir.env; fi
    - echo "SPACK_BUILD_DIR=${SPACK_BUILD_DIR}" >> ${CI_PROJECT_DIR}/spack_build_dir.env
    - echo "SPACK_FULL_SPEC=${SPACK_FULL_SPEC}" >> ${CI_PROJECT_DIR}/spack_build_dir.env
    - echo "SPACK_SOURCE_DIR=${SPACK_SOURCE_DIR}" >> ${CI_PROJECT_DIR}/spack_build_dir.env
    - echo "SPACK_PACKAGE_DEPENDENCIES=${SPACK_PACKAGE_DEPENDENCIES}" >> ${CI_PROJECT_DIR}/spack_build_dir.env
    # Return a meaningful status code by inspecting install.xml. This only
    # loads modules in a subshell so it doesn't pollute the environment. The
    # snippet counts the number of <failure> tags in the XML.
    - num_failures=$(module load unstable python-dev; python -c "from lxml import etree; xml = etree.parse('${CI_PROJECT_DIR}/install.xml'); print(sum(1 for x in xml.getroot().iter('failure')))")
    - echo "Returning the number of failed builds, ${num_failures}"
    - exit ${num_failures}
  needs: ["spack_setup"]
  artifacts:
    when: always
    paths:
      - install.xml
      - spack_build_dir.env
      - initial_environment.env
      - spack-build-env.txt
      - spack-build-out.txt
      - spack-configure-args.txt
    reports:
      junit: install.xml
      dotenv: spack_build_dir.env
  cache:
    key: ${SPACK_PACKAGE}-${SPACK_PACKAGE_COMPILER}
    paths:
      - ccache/
    policy: pull-push

.spack_test:
  stage: test
  variables:
    # Just running tests, no need to check anything out
    GIT_STRATEGY: none
    # Make CI_BUILDS_DIR be the top-level pipeline-global directory
    bb5_build_dir: pipeline
    # Run tests with many 1-core tasks instead of 1 many-core task, as this
    # means that naive `mpirun -n ...` should work.
    bb5_ntasks: 8
    bb5_cpus_per_task: 1
    GIT_CLONE_PATH: ${CI_BUILDS_DIR}/${CI_JOB_ID}
  before_script:
    # Dump the environment for debugging purposes
    - env -0 | sort -z | xargs -0 -L 1 echo > initial_environment.env
    # Tell CTest to use the available slots. This may not quite be correct if
    # the tasks are allocated across several nodes.
    - export CTEST_PARALLEL_LEVEL=${SLURM_TASKS_PER_NODE}
    # Load the Spack installation that knows about the package to be tested.
    - . ${SPACK_ROOT}/share/spack/setup-env.sh
  script:
    - spack load ${SPACK_FULL_SPEC}
    - sh ${SPACK_SOURCE_DIR}/.ci/test_${CI_JOB_NAME}.sh
  artifacts:
    when: always
    paths:
      - initial_environment.env

.ctest:
  extends: .spack_test
  script:
    # Change to the build directory of the package being tested. This is
    # somewhere under the working directory of a previous job in the pipeline.
    - cd ${SPACK_BUILD_DIR}
    # Yuck, but otherwise boost unit tests output colour codes as part of
    # ctest -VV and the XML translation fails.
    - export BOOST_TEST_COLOR_OUTPUT=no
    # Make sure we return a helpful exit code.
    - i_am_a_failure=0
    - spack build-env ${SPACK_FULL_SPEC} -- ctest -VV -T Test || i_am_a_failure=1
    # Save the Testing/ directory as job artifacts
    - cp -r Testing/ ${CI_PROJECT_DIR}/
    # Make an XML report file the GitLab UI can display
    - module load unstable unit-test-translator
    - cmake2junit > ${CI_PROJECT_DIR}/ctest.xml
    - exit ${i_am_a_failure}
  artifacts:
    when: always
    paths:
      # Ugly to re-declare this from .spack_test, but oh well.
      - initial_environment.env
      - Testing/
    reports:
      junit: ctest.xml
